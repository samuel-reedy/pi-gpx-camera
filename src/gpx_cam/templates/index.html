<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Video Stream</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="/static/css/styles.css">
    <script src="/jmuxer.min.js"></script>
</head>
<body>
    <div id="streamStage">

        <div id="topBar">
            <div id="controls">
                <div id="latLon"></div>
            </div>
            <div id="controls">
                <div id="controlText">
                    <label for="exposureSpinner">EXPOSURE:</label>
                    <input id="exposureSpinner" class="controlSpinner" type="number" min="100" max="20000" value=$exposure step="100">
                </div>
                <div id="controlText">
                    <label for="framerateSpinner">FRAMERATE:</label>
                    <input id="framerateSpinner" class="controlSpinner" type="number" min="1" max="30" value=$fps step="1">
                </div>
            </div>
            <div id="controls">
                <input type="text" id="videoFile" name="videoFile" placeholder="Filename" onchange="sendFilename(this.value)">
                <button id="recordButton">Start</button>
                <button id="fileManagerButton" onclick="openFileManager()">File Manager</button>
            </div>
        </div>

        <div id="video-container">
            <video autoplay muted id="stream"></video>
            <canvas id="canvas"></canvas>  
        </div>

        <div id="gauge-container">
            <svg id="depth-gauge" width="100%" height="100%">
            <circle id="ideal-depth" class="gauge" cx="50%" cy="50%" r="50"></circle>
            <circle id="current-depth" class="gauge" cx="50%" cy="50%" r="50"></circle>
            </svg>
        </div>

        <div id="bottomBar">
            <div id="controls">
                <div id="statusText"></div>
            </div>
            
        </div>
        
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var topBarHeight = document.getElementById('topBar').offsetHeight;
            var streamStage = document.getElementById('streamStage');
            // streamStage.style.margin = topBarHeight + 'px';
            console.log("topBarHeight", topBarHeight)
        });
                var isRecording = $isRecording;

        function sendFilename(filename) {
            var xhr = new XMLHttpRequest();
            xhr.open("POST", '/filename', true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            xhr.send('videoFile=' + encodeURIComponent(filename));
        }

        function mapDistanceToRadius(distance) {
            return (100 * distance + 200);
        }

        // Crude way of setting the page state based on the sse json data sent at 1 FPS
        var source = new EventSource('/status/');
        const currentDepthCircle = document.getElementById('current-depth');
        const idealDepthCircle = document.getElementById('ideal-depth');
        const idealDepth = 1; // Example ideal depth
        const idealRadius = mapDistanceToRadius(idealDepth);
        idealDepthCircle.setAttribute('r', idealRadius);

        function updateGauge(currentDepth) {
            const depthDifference = (idealDepth - currentDepth);
            const currentRadius = mapDistanceToRadius(depthDifference);
            currentDepthCircle.setAttribute('r', currentRadius);
        }

        source.onmessage = function(event) {
            var data = JSON.parse(event.data);
            if (data.latitude && data.longitude) {
            var latLonAltitude = 'Latitude: ' + data.latitude + ', Longitude: ' + data.longitude + ', Altitude: ' + data.altitude;
            document.getElementById('latLon').innerHTML = latLonAltitude;
            }
            // set the record button state based on the recording status
            isRecording = data.isRecording;
            document.getElementById('recordButton').textContent = isRecording ? 'Stop' : 'Start';
            // Update the background color based on the recording status
            recordButton.style.backgroundColor = isRecording ? 'red' : 'green';
            //filename
            // document.getElementById('videoFile').value = data.record_filename;

            // Status text
            document.getElementById('statusText').innerHTML = data.status;
            
            // Update the gauge
            updateGauge(-(data.altitude));

        };

        
        var statusSource = new EventSource('/status/');
        statusSource.onmessage = function(event) {
            // console.log(event.data);
            document.getElementById('statusText').innerHTML = event.data;
        };

        document.getElementById('recordButton').addEventListener('click', function() {
            isRecording = !isRecording;
            this.textContent = isRecording ? 'Stop' : 'Start';
            this.style.backgroundColor = isRecording ? 'red' : 'green';

            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/record', true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            xhr.send('isRecording=' + encodeURIComponent(isRecording));
        });

        document.addEventListener('DOMContentLoaded', function() {
            const exposureSpinner = document.getElementById('exposureSpinner');
            const framerateSpinner = document.getElementById('framerateSpinner');

            exposureSpinner.addEventListener('change', function() {
            let exposureValue = parseInt(this.value, 10);
            if (isNaN(exposureValue)) return; // Exit if the value is not a number

            // Clamp the value to ensure it's within the desired range
            exposureValue = Math.max(100, Math.min(exposureValue, 20000));
            this.value = exposureValue; // Update the input with the clamped value
            fetch('/set-exposure', {
                method: 'POST',
                headers: {
                'Content-Type': 'application/json',
                },
                body: JSON.stringify({ exposure: exposureValue }),
            })
            .then(response => {
                if (response.ok) {
                return response.json();
                }
                throw new Error('Network response was not ok.');
            })
            .then(data => {
                console.log('Success:', data);
            })
            .catch((error) => {
                console.error('Error:', error);
            });
            });

            framerateSpinner.addEventListener('change', function() {
            let framerateValue = parseInt(this.value, 10);
            if (isNaN(framerateValue)) return; // Exit if the value is not a number

            // Clamp the value to ensure it's within the desired range
            framerateValue = Math.max(1, Math.min(framerateValue, 30));
            this.value = framerateValue; // Update the input with the clamped value
            fetch('/set-framerate', {
                method: 'POST',
                headers: {
                'Content-Type': 'application/json',
                },
                body: JSON.stringify({ framerate: framerateValue }),
            })
            .then(response => {
                if (response.ok) {
                return response.json();
                }
                throw new Error('Network response was not ok.');
            })
            .then(data => {
                console.log('Success:', data);
            })
            .catch((error) => {
                console.error('Error:', error);
            });
            });
        });

        class Center {
            constructor() {
                this.stream = document.getElementById("stream");
                this.canvas = document.getElementById("canvas");
                this.context = this.canvas.getContext('2d');
                this.thickness = 4;  // Assuming a default thickness
                this.offset = Math.floor(this.thickness / 2);
                this.fps = 0;
                this.frameTimes = [];
                this.maxFrameCount = 10;
            }

            render() {
                let width = this.stream.clientWidth;
                let height = this.stream.clientHeight;
                this.canvas.width = width;
                this.canvas.height = height;
                //this.context.fillStyle = 'rgba(255, 255, 255, 0.5)';  // Assuming white color with transparency

                //this.context.fillRect(width / 2 - this.offset, 0, this.thickness, height);
                //this.context.fillRect(0, height / 2 - this.offset, width, this.thickness);

                //this.calculateFps();
                //this.writeFpsText();
            }

            calculateFps() {
                let currentTime = performance.now();
                if (this.lastFrameTime) {
                    let diff = currentTime - this.lastFrameTime;
                    let fps = diff !== 0 ? 1000 / diff : 0;
                    this.frameTimes.push(fps);

                    if (this.frameTimes.length > this.maxFrameCount) {
                        this.frameTimes.shift();
                    }

                    let total = this.frameTimes.reduce((a, b) => a + b, 0);
                    this.fps = total / this.frameTimes.length;
                }
                this.lastFrameTime = currentTime;
            }

            writeFpsText() {
                this.context.font = '20px Arial';
                this.context.fillStyle = 'white';
                this.context.fillText(`FPS: ` + this.fps.toFixed(1), 10, 30);
            }
        }

        window.onload = function() {
            var ws
            const jmuxer = new JMuxer({
                node: 'stream',
                mode: 'video',
                flushingTime: 0,
                fps: $fps,  // Assuming a default fps value
                debug: false
            });

            const center = new Center();

            function startWebSocket() {
                ws = new WebSocket("ws://$ip:$port/ws/");
                ws.binaryType = 'arraybuffer';

                ws.addEventListener('message', function(event) {
                    // console.log('Received message type:', typeof event.data);
                    // console.log('Data byteLength:', event.data.byteLength); // Log the byteLength of the received data
                    // http://10.42.0.116:8075/center/
                    if (!document.hidden) {
                        jmuxer.feed({
                            video: new Uint8Array(event.data)
                        });

                        center.render();
                    }
                });



                ws.addEventListener('close', function() {
                    console.log('WebSocket closed, retrying...');
                    setTimeout(startWebSocket, 1000);
                });
            }

            startWebSocket();

            window.onresize = function() {
                center.render();
            };
            window.onorientationchange = function() {
                center.render();
            };

            // set record button state
            document.getElementById('recordButton').textContent = isRecording ? 'Stop' : 'Start';
            recordButton.style.backgroundColor = isRecording ? 'red' : 'green';

        };

        function openFileManager() {
            window.open("http://192.168.2.3:8085", "_blank");
        }

        

    </script>
</body>
</html>
